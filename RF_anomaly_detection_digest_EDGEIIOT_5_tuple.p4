########################################################################
# THIS FILE IS PART OF Planter PROJECT
# Copyright (c) Changgang Zheng and Computing Infrastructure Lab
# Departement of Engineering Science, University of Oxford
# All rights reserved.
# E-mail: changgang.zheng@eng.ox.ac.uk or changgangzheng@qq.com
# Modified by: Mingyuan Zang at Technical University of Denmark
# E-mail: minza@dtu.dk
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at :
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#########################################################################
# This file was autogenerated
# Based on: https://github.com/ksingh25/SwitchTree.git
# Based on: C. Busse-Grawitz, R. Meier, A. Dietm ̈uller, T. B ̈uhler, and L. Vanbever,
# “pForest: In-network inference with random forests,” arXiv preprint, arXiv:1909.05680, 2019 

#define CLASS_NOT_SET 10

#include <core.p4>
#include <v1model.p4>

/*************************************************************************
*********************** headers and metadata *****************************
*************************************************************************/

typedef bit<48> mac_addr_t;
typedef bit<32> ipv4_addr_t;
typedef bit<9> egressSpec_t;
const bit<16> ETHERTYPE_TPID = 0x8100;
const bit<16> ETHERTYPE_IPV4 = 0x0800;
const bit<16> ETHERTYPE_ARP = 0x0806;
typedef bit<8> ip_protocol_t;
const ip_protocol_t IP_PROTOCOLS_UDP = 17;
const bit<8> UDP_TYPE = 0x11;
const bit<8> TCP_TYPE = 0x06;
const int IPV4_HOST_TABLE_SIZE = 65536;

header ethernet_h {
    mac_addr_t dst_addr;
    mac_addr_t src_addr;
    bit<16> ether_type;
}

header ipv4_h {
    bit<4> version;
    bit<4> ihl;
    bit<8> diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3> flags;
    bit<13> frag_offset;
    bit<8> ttl;
    bit<8> protocol;
    bit<16> hdr_checksum;
    ipv4_addr_t src_addr;
    ipv4_addr_t dst_addr;
}

header l4_ports_t {
    bit<16>   l4_srcPort;
    bit<16>   l4_dstPort;
    }
header udp_h{
    bit<16> hdr_length;
    bit<16> checksum;
}

header tcp_h{
    int<32> seqNo;
    int<32> ackNo;
    bit<4> data_offset;
    bit<3>  res;
    bit<3>  ecn;        //Explicit congestion notification
    bit<6>  ctrl;       // URG,ACK,PSH,RST,SYN,FIN
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header arp_h{
    bit<16> hwType;
    bit<16> protoType;
    bit<8> hwAddrLen;
    bit<8> protoAddrLen;
    bit<16> opcode;
    bit<48> hwSrcAddr;
    bit<32> protoSrcAddr;
    bit<48> hwDstAddr;
    bit<32> protoDstAddr;
}

header vlan_tag_h{
    bit<3> pcp;
    bit<1> dei;
    bit<12> vid;
    bit<16> ether_type;
    }

struct header_t {
    ethernet_h   ethernet;
    vlan_tag_h   vlan_tag;
    ipv4_h       ipv4;
    arp_h        arp;
    l4_ports_t   l4_ports;
    tcp_h        tcp;
    udp_h        udp;
}

struct int_cpu_digest_t
    {
    	bit<32> ip_src;
    	bit<32> ip_dst;
    	bit<32> feature0;
     bit<32> feature1;
     bit<32> feature2;
    	bit<32> feature3;
    	bit<32> feature4;
    	bit<4>  malware;
    	bit<4>  class;
    }

struct metadata_t {
    bit<16> tree_1_vote;
    bit<16> tree_2_vote;
    bit<16> tree_3_vote;
    bit<16> tree_4_vote;
    bit<16> tree_5_vote;
    bit<16> node_id;
    bit<16> prevFeature;
    bit<16> isTrue;
    bit<32>  DstAddr;
    bit<32> feature0;
    bit<32> feature1;
    bit<32> feature2;
    bit<32> feature3;
    bit<32> feature4;
    bit<32> srcip;
    bit<32> dstip;
    bit<32> result;
    bit<32> class;
    bit<4> malware;
    bit<1> send_int_cpu_digest;
    bit<8> flag ;
}

/*************************************************************************
*********************** Ingress Parser ***********************************
*************************************************************************/

parser SwitchParser(
    packet_in pkt,
    out header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t ig_intr_md) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.ether_type) {
            ETHERTYPE_TPID:  parse_vlan_tag;
            ETHERTYPE_IPV4:  parse_ipv4;
            ETHERTYPE_ARP:  parse_arp;
            default: accept;
        }
    }

    state parse_vlan_tag {
        pkt.extract(hdr.vlan_tag);
        transition select(hdr.vlan_tag.ether_type) {
            ETHERTYPE_IPV4:  parse_ipv4;
            default: accept;
        }
    }


    state parse_ipv4 {
        pkt.extract(hdr.ipv4);
        meta.srcip = (bit<32>) hdr.ipv4.src_addr;
        meta.dstip = (bit<32>) hdr.ipv4.dst_addr;
        meta.feature0 = (bit<32>)(bit<8>) hdr.ipv4.src_addr;
        meta.feature1 = (bit<32>)(bit<8>) hdr.ipv4.dst_addr;
        transition select(hdr.ipv4.protocol) {
            UDP_TYPE:  parse_udp_ports;
            TCP_TYPE:  parse_tcp_ports;
            default: accept;
        }
    }

    state parse_arp {
        pkt.extract(hdr.arp);
        transition accept;
    }

    state parse_tcp_ports{
        pkt.extract(hdr.l4_ports);
        meta.feature2 = (bit < 32 >)hdr.l4_ports.l4_srcPort;
        meta.feature3 = (bit < 32 >)hdr.l4_ports.l4_dstPort;
        transition parse_tcp;
    }
    state parse_udp_ports{
        pkt.extract(hdr.l4_ports);
        meta.feature2 = (bit < 32 >)hdr.l4_ports.l4_srcPort;
        meta.feature3 = (bit < 32 >)hdr.l4_ports.l4_dstPort;
        transition parse_udp;
    }
    state parse_udp { 
        pkt.extract(hdr.udp);
        transition accept;
    }

    state parse_tcp {
        pkt.extract(hdr.tcp);
        meta.feature4 = (bit<32>)hdr.tcp.ctrl;
        transition accept;
    }

}

/*************************************************************************
*********************** Egress Deparser *********************************
**************************************************************************/

control SwitchDeparser(
    packet_out pkt,
    in header_t hdr) {
    apply {
        pkt.emit(hdr);
    }
}

/*************************************************************************
********************** Checksum Verification *****************************
*************************************************************************/

control SwitchVerifyChecksum(inout header_t hdr,
                       inout metadata_t meta) {
    apply {}
}
/*************************************************************************
********************** Checksum Computation ******************************
*************************************************************************/

control SwitchComputeChecksum(inout header_t hdr,
                        inout metadata_t meta) {
    apply {}
}
/*************************************************************************
*********************** Ingress Processing********************************
**************************************************************************/

control SwitchIngress(
    inout header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t ig_intr_md) {

    action send(bit<9> port) {
        ig_intr_md.egress_spec = port;
    }

    action drop() {
        mark_to_drop(ig_intr_md);
    }

    counter(1, CounterType.packets) counter_true_attack;
    counter(1, CounterType.packets) counter_false_attack; 
    counter(1, CounterType.packets) counter_false_benign;
    counter(1, CounterType.packets) counter_true_benign;

    action ipv4_forward(mac_addr_t dstAddr, egressSpec_t port) {
        send(port);
        hdr.ethernet.src_addr = hdr.ethernet.dst_addr;
        hdr.ethernet.dst_addr = dstAddr;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }

    table decision_mitigation {
        key = {
            meta.result: exact;
        }
        actions={
            drop;
        }
        size = 4;
        default_action = drop();
    }

    table fwd_tb {
    key = {
        hdr.ipv4.dst_addr : lpm;
    }
    actions = {
        ipv4_forward;
        drop;
        NoAction;
    }
    default_action = drop;
    }

    action SetMalware(bit<4> malware_flag) {
    meta.malware = malware_flag;
    }

    table malware{ 
    key = {
        hdr.ipv4.src_addr: lpm;
        }
        actions = {
        NoAction;
        SetMalware;
        }
        size = 10;
        default_action = NoAction();
        }

    table malware_inverse { 
    key = {
        hdr.ipv4.dst_addr: lpm;
     }
     actions = {
               NoAction;
               SetMalware;
      }
      size = 10;
      default_action = NoAction();
      }

    action CheckFeature(bit<16> node_id, bit<16> f_inout, bit<32> threshold) {
        bit<32> feature = 0;
        bit<16> f = f_inout ;
        if (f == 0) {
            feature = meta.feature0;
        }
        if (f == 1) {
            feature = meta.feature1;
        }
        if (f == 2) {
            feature = meta.feature2;
        }
        if (f == 3) {
            feature = meta.feature3;
        }
        if (f == 4) {
            feature = meta.feature4;
        }
        bit<32> th = threshold - feature;
        if (th & 0b10000000000000000000000000000000==0){
            meta.isTrue = 1;
        }else{
            meta.isTrue = 0;
        }
        meta.prevFeature = f;
        meta.node_id = node_id;
    }

    action SetClass1(bit <16> node_id, bit <16> class ) {
        meta.tree_1_vote = class;
        meta.node_id = node_id; // just for debugging otherwise not needed
    }
    action SetClass2(bit <16> node_id, bit <16> class ) {
        meta.tree_2_vote = class;
        meta.node_id = node_id; // just for debugging otherwise not needed
    }
    action SetClass3(bit <16> node_id, bit <16> class ) {
        meta.tree_3_vote = class;
        meta.node_id = node_id; // just for debugging otherwise not needed
    }
    action SetClass4(bit <16> node_id, bit <16> class ) {
        meta.tree_4_vote = class;
        meta.node_id = node_id; // just for debugging otherwise not needed
    }
    action SetClass5(bit <16> node_id, bit <16> class ) {
        meta.tree_5_vote = class;
        meta.node_id = node_id; // just for debugging otherwise not needed
    }
    table level_1_1{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass1;
        }
        size = 1024;
    }

    table level_1_2{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass1;
        }
        size = 1024;
    }

    table level_1_3{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass1;
        }
        size = 1024;
    }

    table level_1_4{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass1;
        }
        size = 1024;
    }

    table level_1_5{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass1;
        }
        size = 1024;
    }

    table level_2_1{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass2;
        }
        size = 1024;
    }

    table level_2_2{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass2;
        }
        size = 1024;
    }

    table level_2_3{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass2;
        }
        size = 1024;
    }

    table level_2_4{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass2;
        }
        size = 1024;
    }

    table level_2_5{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass2;
        }
        size = 1024;
    }

    table level_3_1{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass3;
        }
        size = 1024;
    }

    table level_3_2{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass3;
        }
        size = 1024;
    }

    table level_3_3{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass3;
        }
        size = 1024;
    }

    table level_3_4{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass3;
        }
        size = 1024;
    }

    table level_3_5{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass3;
        }
        size = 1024;
    }

    table level_4_1{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass4;
        }
        size = 1024;
    }

    table level_4_2{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass4;
        }
        size = 1024;
    }

    table level_4_3{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass4;
        }
        size = 1024;
    }

    table level_4_4{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass4;
        }
        size = 1024;
    }

    table level_4_5{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass4;
        }
        size = 1024;
    }

    table level_5_1{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass5;
        }
        size = 1024;
    }

    table level_5_2{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass5;
        }
        size = 1024;
    }

    table level_5_3{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass5;
        }
        size = 1024;
    }

    table level_5_4{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass5;
        }
        size = 1024;
    }

    table level_5_5{
        key = {
            meta.node_id: exact;
            meta.prevFeature: exact;
            meta.isTrue: exact;
        }
        actions = {
            NoAction;
            CheckFeature;
            SetClass5;
        }
        size = 1024;
    }

    action read_lable(bit<32> label){
        meta.result = label;
    }

    action write_default_decision() {
        meta.result = 0;
    }

    table decision {
        key = { meta.tree_1_vote:exact;
                meta.tree_2_vote:exact;
                meta.tree_3_vote:exact;
                meta.tree_4_vote:exact;
                meta.tree_5_vote:exact;
                }
        actions={
            read_lable;
            write_default_decision;
        }
        size = 16;
        default_action = write_default_decision;
    }

    apply{
        meta.tree_1_vote = CLASS_NOT_SET;
        meta.tree_2_vote = CLASS_NOT_SET;
        meta.tree_3_vote = CLASS_NOT_SET;
        meta.tree_4_vote = CLASS_NOT_SET;
        meta.tree_5_vote = CLASS_NOT_SET;

        meta.node_id = 0;
        meta.prevFeature = 0;
        meta.isTrue = 1;
        level_1_1.apply();
        if (meta.tree_1_vote == CLASS_NOT_SET) {
          level_1_2.apply();
          if (meta.tree_1_vote == CLASS_NOT_SET) {
            level_1_3.apply();
            if (meta.tree_1_vote == CLASS_NOT_SET) {
              level_1_4.apply();
              if (meta.tree_1_vote == CLASS_NOT_SET) {
                level_1_5.apply();
        } } } } 

        meta.node_id = 7;
        meta.prevFeature = 0;
        meta.isTrue = 1;
        level_2_1.apply();
        if (meta.tree_2_vote == CLASS_NOT_SET) {
          level_2_2.apply();
          if (meta.tree_2_vote == CLASS_NOT_SET) {
            level_2_3.apply();
            if (meta.tree_2_vote == CLASS_NOT_SET) {
              level_2_4.apply();
              if (meta.tree_2_vote == CLASS_NOT_SET) {
                level_2_5.apply();
        } } } } 

        meta.node_id = 18;
        meta.prevFeature = 0;
        meta.isTrue = 1;
        level_3_1.apply();
        if (meta.tree_3_vote == CLASS_NOT_SET) {
          level_3_2.apply();
          if (meta.tree_3_vote == CLASS_NOT_SET) {
            level_3_3.apply();
            if (meta.tree_3_vote == CLASS_NOT_SET) {
              level_3_4.apply();
              if (meta.tree_3_vote == CLASS_NOT_SET) {
                level_3_5.apply();
        } } } } 

        meta.node_id = 29;
        meta.prevFeature = 0;
        meta.isTrue = 1;
        level_4_1.apply();
        if (meta.tree_4_vote == CLASS_NOT_SET) {
          level_4_2.apply();
          if (meta.tree_4_vote == CLASS_NOT_SET) {
            level_4_3.apply();
            if (meta.tree_4_vote == CLASS_NOT_SET) {
              level_4_4.apply();
              if (meta.tree_4_vote == CLASS_NOT_SET) {
                level_4_5.apply();
        } } } } 

        meta.node_id = 36;
        meta.prevFeature = 0;
        meta.isTrue = 1;
        level_5_1.apply();
        if (meta.tree_5_vote == CLASS_NOT_SET) {
          level_5_2.apply();
          if (meta.tree_5_vote == CLASS_NOT_SET) {
            level_5_3.apply();
            if (meta.tree_5_vote == CLASS_NOT_SET) {
              level_5_4.apply();
              if (meta.tree_5_vote == CLASS_NOT_SET) {
                level_5_5.apply();
        } } } } 

        decision.apply();
        malware.apply();
        malware_inverse.apply();
        if (meta.malware != 0) {// meta.malware is calculated with priori knowledge for statistics
             if(meta.result == (bit<32>)meta.malware) {
                counter_true_attack.count(0);
        		decision_mitigation.apply();
            } else {
                counter_false_attack.count(0);// malicious flows but not detected as the exact type
            }
         }
         else {
            if(meta.result == 0) {
                counter_true_benign.count(0); 
        		fwd_tb.apply();
            } else {
                counter_false_benign.count(0);
            }
        }

        	digest<int_cpu_digest_t>(1, {hdr.ipv4.src_addr, hdr.ipv4.dst_addr, meta.feature0, meta.feature1, meta.feature2, meta.feature3, meta.feature4, (bit<4>)meta.malware, (bit<4>)meta.result});
    }
}
/*************************************************************************
*********************** egress Processing********************************
**************************************************************************/

control SwitchEgress(inout header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t eg_intr_md) {
    apply {
    }
}
/*************************************************************************
***********************  S W I T C H  ************************************
*************************************************************************/

V1Switch(
    SwitchParser(),
    SwitchVerifyChecksum(),
    SwitchIngress(),
    SwitchEgress(),
    SwitchComputeChecksum(),
    SwitchDeparser()
) main;
